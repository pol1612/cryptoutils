/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package cat.uvic.teknos.m09.polsane.cryptoutils;

import cat.uvic.teknos.m09.polsane.cryptoutils.CryptoUtils;
import cat.uvic.teknos.m09.polsane.cryptoutils.exceptions.AlgorithmNotFoundException;
import cat.uvic.teknos.m09.polsane.cryptoutils.exceptions.IncorrectKeyException;
import com.google.common.base.Ascii;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import javax.crypto.BadPaddingException;
import java.io.IOException;
import java.lang.reflect.Array;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.Base64;

import static org.junit.jupiter.api.Assertions.*;

class CryptoUtilsTest {
    @Test void When_Hash1SameAlgorithmAndNoSaltAsHash2_Expect_Hash1EqualsHash2AsTrue() {
        synchronized (CryptoUtils.class) {
            CryptoUtils.getProperties().setProperty("hash.algorithm","SHA-256");
            CryptoUtils.getProperties().setProperty("hash.salt","false");
            var message = "message";
            var digestResult1 = CryptoUtils.hash(message.getBytes());
            var digestResult2=CryptoUtils.hash(message.getBytes());
            assertTrue(Arrays.equals(digestResult1.getHash(),digestResult2.getHash()));
        }
    }
    @Test void When_Hash1SameAlgorithmAsHash2AndHasSaltAndHash2HasNoSalt_Expect_Hash1EqualsHash2AsFalse() {
        synchronized (CryptoUtils.class) {
            CryptoUtils.getProperties().setProperty("hash.algorithm","SHA-256");
            CryptoUtils.getProperties().setProperty("hash.salt","true");
            var message = "message";
            var digestResult1 = CryptoUtils.hash(message.getBytes());
            CryptoUtils.getProperties().setProperty("hash.salt","false");
            var digestResult2=CryptoUtils.hash(message.getBytes());
            assertFalse(Arrays.equals(digestResult1.getHash(),digestResult2.getHash()));
        }
    }
    @Test() void When_CreatingHashAlgorithmPropertyIsNotRight_Expect_AlgorithmNotFoundException() {
        synchronized (CryptoUtils.class) {
            CryptoUtils.getProperties().setProperty("hash.salt","false");
            CryptoUtils.getProperties().setProperty("hash.algorithm","1234");
            var message = "message";
            AlgorithmNotFoundException algorithmNotFoundException=  assertThrows(AlgorithmNotFoundException.class, () ->
                   CryptoUtils.hash(message.getBytes())
            );
            Assertions.assertEquals("The algorithm of cryptoutils.properties does not exist.ck if it's written correctly and if before there is 'hash.algorithm=' and nothing else \n",algorithmNotFoundException.getMessage());
        }
    }
    @Test() void When_EncryptingAndDecryptingTextUsingSamePassword_Expect_InitialTextEqualsFinalTextAsTrue() {
        synchronized (CryptoUtils.class) {
            var initialTextString="my name is Pol";
            var password="123pol";
            var initialTextByteArr= initialTextString.getBytes();
            byte[] encryptedTextByteArr =CryptoUtils.encrypt(initialTextByteArr,password);
            byte[] decryptedTextByteArr=CryptoUtils.decrypt(encryptedTextByteArr,password);
            String decryptedTex=new String(decryptedTextByteArr);
            assertTrue(initialTextString.equals(decryptedTex));
        }
    }
    @Test() void When_EncryptingAndDecryptingTextUsingDifferent_Expect_InitialTextEqualsFinalTextAsTrue() {
        synchronized (CryptoUtils.class) {
            var initialTextString="my name is Pol";
            var password="123pol";
            var password2="12345pol";
            var initialTextByteArr= initialTextString.getBytes();
            byte[] encryptedTextByteArr =CryptoUtils.encrypt(initialTextByteArr,password);
            assertThrows(IncorrectKeyException.class, () ->
                CryptoUtils.decrypt(encryptedTextByteArr,password2)
            );
        }
    }
}
